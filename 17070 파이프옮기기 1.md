# 문제

유현이가 새 집으로 이사했다. 새 집의 크기는 N×N의 격자판으로 나타낼 수 있고, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 (r, c)로 나타낼 수 있다. 여기서 r은 행의 번호, c는 열의 번호이고, 행과 열의 번호는 1부터 시작한다. 각각의 칸은 빈 칸이거나 벽이다.

오늘은 집 수리를 위해서 파이프 하나를 옮기려고 한다. 파이프는 아래와 같은 형태이고, 2개의 연속된 칸을 차지하는 크기이다.

![img](https://upload.acmicpc.net/3ceac594-87df-487d-9152-c532f7136e1e/-/preview/)

파이프는 회전시킬 수 있으며, 아래와 같이 3가지 방향이 가능하다.

![img](https://upload.acmicpc.net/b29efafa-dbae-4522-809c-76d5c184a231/-/preview/)

파이프는 매우 무겁기 때문에, 유현이는 파이프를 밀어서 이동시키려고 한다. 벽에는 새로운 벽지를 발랐기 때문에, 파이프가 벽을 긁으면 안 된다. 즉, 파이프는 항상 빈 칸만 차지해야 한다.

파이프를 밀 수 있는 방향은 총 3가지가 있으며, →, ↘, ↓ 방향이다. 파이프는 밀면서 회전시킬 수 있다. 회전은 45도만 회전시킬 수 있으며, 미는 방향은 오른쪽, 아래, 또는 오른쪽 아래 대각선 방향이어야 한다.

파이프가 가로로 놓여진 경우에 가능한 이동 방법은 총 2가지, 세로로 놓여진 경우에는 2가지, 대각선 방향으로 놓여진 경우에는 3가지가 있다.

아래 그림은 파이프가 놓여진 방향에 따라서 이동할 수 있는 방법을 모두 나타낸 것이고, 꼭 빈 칸이어야 하는 곳은 색으로 표시되어져 있다.

![img](https://upload.acmicpc.net/0f445b26-4e5b-4169-8a1a-89c9e115907e/-/preview/)

가로

![img](https://upload.acmicpc.net/045d071f-0ea2-4ab5-a8db-61c215e7e7b7/-/preview/)

세로

![img](https://upload.acmicpc.net/ace5e982-6a52-4982-b51d-6c33c6b742bf/-/preview/)

대각선

가장 처음에 파이프는 (1, 1)와 (1, 2)를 차지하고 있고, 방향은 가로이다. 파이프의 한쪽 끝을 (N, N)로 이동시키는 방법의 개수를 구해보자.

## 입력

첫째 줄에 집의 크기 N(3 ≤ N ≤ 16)이 주어진다. 둘째 줄부터 N개의 줄에는 집의 상태가 주어진다. 빈 칸은 0, 벽은 1로 주어진다. (1, 1)과 (1, 2)는 항상 빈 칸이다.

## 출력

첫째 줄에 파이프의 한쪽 끝을 (N, N)으로 이동시키는 방법의 수를 출력한다. 이동시킬 수 없는 경우에는 0을 출력한다. 방법의 수는 항상 1,000,000보다 작거나 같다.







내 풀이

```python
def func():
    global route
    # 초기 x,y의 위치를 설정
    # 파이프의 뒷부분이 목적지에 도착해야하므로 뒷부분이 위치하는 곳을 기준으로 한다. 
    x, y = 1, 2
    # [해당 위치에 가로로 위치할 수 있는 경우의 수, 세로로 위치할 수 있는 경우의 수, 대각으로 위치할 수 있는 경우의 수]
    # 해당 문제에서는 가로로 (1, 2) 위치하므로 초기값을 설정해준다.
    route[x][y] =[1,0,0]
    
    # route를 0부터 N까지의 크기로 설정하였으므로 x의 값이 N일때 까지 while문을 설정하였다.
    while x != N:
   		# route 배열을 (0,0), (1,1), (2,2),,,를 기준으로 세로 가로를 채워 나갔다.
        # x, y = 1, 2 일때 (2,2), (3,2), (4,2),,, 와 같이 세로의 경우의 수를 확인하고 이후 가로의 경우의 수를 확인했다.
        for i in range(N+1-x):
            # 경우의수를 확인하는 지점에 벽이 있는지 확인한다.
            if route[x+i][y] == [0,0,0] and not arr[x-1+i][y-1]:
                # 가로로 배치 될 수 있는 경우의 수는 y-1 위치에서 오는 방법 뿐이다.
                # y-1 위치에서 가로방향이었을 경우와 대각선 방향이었을 경우다.
                route[x+i][y][0] = route[x+i][y-1][0]+route[x+i][y-1][2]
                # 마찬가지로 세로로 배치 될 수 있는 경우의 수는 x-1 위치에서 오는 방법이다.
                route[x+i][y][1] = route[x+i-1][y][1]+route[x+i-1][y][2]
                # 대각선으로 배치 될 수 있는 경우의 수는 해당 위치의 벽 뿐아니라 
                # x-1 위치와 y-1 위치 역시 벽이 없어야한다.
                # arr은 route보다 크기가 1 작으므로 1씩 작게해준다.
                if not arr[x - 2 + i][y - 1] and not arr[x + i - 1][y-2]:
                    route[x+i][y][2] = route[x+i-1][y-1][2]+route[x+i-1][y-1][1]+route[x+i-1][y-1][0]
        # 가로로 경우의 수를 채우는 for 문이다.
        for j in range(N+1-y):
            if route[x][y+j] == [0,0,0] and not arr[x-1][y-1+j]:
                route[x][y+j][0] = route[x][y+j-1][0]+route[x][y+j-1][2]
                route[x][y+j][1] = route[x-1][y+j][1]+route[x-1][y+j][2]
                if not arr[x - 2][y - 1 + j] and not arr[x - 1][y - 2 + j]:
                    route[x][y+j][2] = route[x-1][y+j-1][2]+route[x-1][y-1+j][1]+route[x-1][y+j-1][0]
		# 가로세로의 경우의 수를 확인후 x와 y를 1씩 추가해준다.
        x += 1
        y += 1

N = int(input())
arr = [list(map(int,input().split())) for _ in range(N)]
# 문제의 좌표가 1부터 시작하므로 입력받은 N보다 1 여유 있는 배열을 생성 하였다.
route = [list([0,0,0] for k in range(N+1)) for _ in range(N+1)]
func()
# 목적지에서 가능한 경우의 수를 더해준다.
print(sum(route[N][N]))

"""
3
0 0 0
0 0 0
0 0 0
"""
# 1
"""
4
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
"""
# 3
"""
5
0 0 1 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
"""
# 0
"""
6
0 0 0 0 0 0 
0 1 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0

"""
# 13
```



* 간단한 문제라고 생각하고 처음엔 재귀함수 호출을 이용하여 문제를 풀어보았다. 답은 잘 나왔지만 배열의 크기가 큰 case가 나오자 시간초과로 문제를 해결하지 못하는 결과를 보였다. 



실패한 풀이

```python
# state : 가로 1 세로 2 대각 3
def func(state, position):
    global result
    x, y = position[1][0],position[1][1]
	
    # x, y 가 도착지이면 1을 증가시키고 함수 종료
    if x == N-1 and y == N-1:
        result += 1
        return
    # 대각이거나 가로방향일 때 
    # 벽이 아닐 때
    # 가로 방향으로 놓이는 경우의 함수를 호출
    if (state == 3 or state == 1) and y+1 < N and not arr[x][y+1]:
        func(1,[(x,y),(x,y+1)])
    
    # 대각으로 놓이는 경우의 함수 호출
    if x+1 < N and y+1 < N and not arr[x+1][y+1] and not arr[x][y+1] and not arr[x+1][y]:
        func(3,[(x,y),(x+1,y+1)])
        
    # 세로로 놓이는 경우의 함수 호출  
    if (state == 3 or state == 2) and x+1 < N and not arr[x+1][y]:
        func(2,[(x,y),(x+1,y)])

N = int(input())
arr = [list(map(int,input().split())) for _ in range(N)]

# state = 1
# position = [(0,0),(0,1)]

result = 0
func(1,[(0,0),(0,1)])

# 호출된 함수중 도착지에 도착한 함수의 개수를 출력
print(result)

```



모든 경우의 수를 함수로 호출하다 보니 시간초과가 나왔던것 같다.

문제를 해결하기위해 배열의 각 지점에 가능한 경우의 수를 기록하는 방법으로 바꾸었다.

